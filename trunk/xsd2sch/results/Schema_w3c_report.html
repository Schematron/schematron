<html><head><title>XML Schema to Schematron result</title></head><body><p>Green = valid. Blue = invalid. Red = false invalid. Yellow = false valid.</p><table><tr><th>Name</th><th>Test</th><th>Expected</th><th>Found</th><th>OK</th></tr><tr><td>msData/schema/schA1.xml</td><td>TEST :schema collection and schema location : Schema Collection: (A,a.xsd), SchemaLocation: (B,b.xsd), NoNSSchemaLocation: c.xsd</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schA2.xml</td><td>TEST :schema collection and schema location : Schema Collection:(A,a.xsd), SchemaLocation: (A,b.xsd), NoNSSchemaLocation:, expected: the xml instance must conform to (A,a.xsd), the inline schemaLocation (A,b.xsd) is ignored.</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">false</td></tr><tr><td>msData/schema/schA3.xml</td><td>TEST :schema collection and schema location : Schema Collection:(A,a.xsd), SchemaLocation:, NoNSSchemaLocation:,</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schA5.xml</td><td>TEST :schema collection and schema location : Schema Collection:(A,a.xsd) (B, b.xsd), SchemaLocation:(B,a.xsd), NoNSSchemaLocation:, xmlinstance should conform to (A,a.xsd)(B,b.xsd), ignore the inline SchemaLocation (B,a.xsd)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schA7.xml</td><td>TEST :schema collection and schema location : Schema Collection:(A,a.xsd), SchemaLocation:(A,c.xsd)(B,b.xsd), NoNSSchemaLocation: The instance xml conform to (A,a.xsd)(B,b.xsd)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schC3.xml</td><td>TEST :schema collection and schema location : XSD A include XSD B, A's ns="", B's ns="", test the namespace of include (4.2.1) (SRC 2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schC4.xml</td><td>TEST :schema collection and schema location : XSD A include XSD B, A's ns="A", B's ns="A", test the namespace of include (4.2.1) (SRC 2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schD5.xml</td><td>TEST :schema collection and schema location : A include B and C, A's ns="A", B's ns="A", C's ns="A", type ref from A to B and C, B to A and C, C to A and B</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schD7.xml</td><td>TEST :schema collection and schema location : A includes B and C, B is bogus URL, C is valid XSD, test that there is no error and C is included.</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schD10.xml</td><td>TEST :schema collection and schema location : validate instance against 'chameleon' include schema (2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schE4.xml</td><td>TEST :schema collection and schema location : import namespace="foo"</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schF1.xml</td><td>TEST :schema collection and schema location : XSD X import XSD Y, X's ns="A", Y's ns="", test the namespace of import</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schF2.xml</td><td>TEST :schema collection and schema location : XSD X import XSD Y, X's ns="", Y's ns="A", test the namespace of import</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schF5.xml</td><td>TEST :schema collection and schema location : XSD X import XSD Y, X's ns="A", Y's ns="B", test the namespace of import</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG1.xml</td><td>TEST :schema collection and schema location : A import B, B import C, A's ns="A", B's ns="B", C's ns="C"</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG2.xml</td><td>TEST :schema collection and schema location : A import B, B import C, A's ns="A", B's ns="", C's ns="C"</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG3.xml</td><td>TEST :schema collection and schema location : A import B, B import C, A's ns="A", B's ns="B", C's ns="A", (A and C have no confilcting decl)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG4.xml</td><td>TEST :schema collection and schema location : A import B and C, A's ns="A", B's ns="B", C's ns="C"</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG5.xml</td><td>TEST :schema collection and schema location : A import B and C, A's ns="A", B's ns="B", C's ns="B", (B and C have no confilcting decl)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG7.xml</td><td>TEST :schema collection and schema location : A imports B and B and C, B imports C and D, C imports D and A, multiple import of the same XSD is ok</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schG8.xml</td><td>TEST :schema collection and schema location : A import B and C, B is bogus URL, C is valid XSD, test that there is no error and C is imported.</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schG12.xml</td><td>TEST :schema collection and schema location : A import B, B import C, A's ns="A", B's ns="B", C's ns="B", All declaration in B and C should be available to validation</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">true</td></tr><tr><td>msData/schema/schP2.xml</td><td>TEST :schema collection and schema location : redefine with a complexType, which has a restriction, (SRC 5)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schQ1.xml</td><td>TEST :schema collection and schema location : redefine with a complexType, which has an extension, (SRC 5)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schQ3.xml</td><td>TEST :schema collection and schema location : redefine with a complexType, which has a restriction, (SRC 5)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schR2.xml</td><td>TEST :schema collection and schema location : redefine with a group, which has a group ref to itself in the middle, group min,maxOccurs is absent, (SRC 6.1.2)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schT3.xml</td><td>TEST :schema collection and schema location : redefine with a attributeGroup, attribute group's content items are a subset of the redefined group, (SRC 7.2.2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schT6.xml</td><td>TEST :schema collection and schema location : redefine with an attributeGroup, attribute group's content items are a subset of the redefined group, test that attribute uses are not inherited. Have a use=optional on redefined attriubte, but have use=required in redefining attribute, and instance xml has no attribute, (SRC 7.2.2)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schT9.xml</td><td>TEST :schema collection and schema location : redefine with a attributeGroup, attribute group's content items are a subset of the redefined group, test that attribute uses are not inherited. Have a default="foo" in redefined attriubte, but redefining attribute has default="bar", the actual value of the instance should have 'bar' as the default attribute value (SRC 7.2.2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schT10.xml</td><td>TEST :schema collection and schema location : redefine with an attributeGroup, attribute group's content items are a subset of the redefined group, test that attribute uses are not inherited. base attriburte with effective value absent, but redefining attribute has fixed="bar" , (SRC 7.2.2)</td><td bgcolor="green">valid</td><td bgcolor="blue">invalid</td><td bgcolor="red">false</td></tr><tr><td>msData/schema/schU3.xml</td><td>TEST :schema collection and schema location : Circulcar redefines handeling (3)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schU4.xml</td><td>TEST :schema collection and schema location : Circulcar redefines handeling (4)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr><tr><td>msData/schema/schU5.xml</td><td>TEST :schema collection and schema location : Circulcar redefines handeling (5)</td><td bgcolor="blue">invalid</td><td bgcolor="blue">invalid</td><td bgcolor="blue">true</td></tr></table></body></html>